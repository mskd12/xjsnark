package xjsnark.strings;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.util.Arrays;
import java.math.BigInteger;
import backend.auxTypes.UnsignedInteger;
import backend.auxTypes.Bit;
import backend.auxTypes.SmartMemory;
import util.Util;
import backend.auxTypes.ConditionalScopeTracker;
import backend.eval.CircuitEvaluator;

public class StockPrice extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    // This method can be left empty, or used to set Configuration params (see examples) 

    Config.multivariateExpressionMinimization = true;
    Config.arithOptimizerNumThreads = 2;
    Config.arithOptimizerTimeoutPerProblemMilliSec = 20000;


    Config.multivariateExpressionMinimization = true;
    Config.arithOptimizerNumThreads = 2;
    Config.arithOptimizerTimeoutPerProblemMilliSec = 20000;

    new StockPrice();
  }

  public StockPrice() {
    super("StockPrice");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        byte[] stateArray = fromHexString("5ecd89f829249455adb28bbcf85b579df0d2056fdcb3aacbf2ad18f1ddc20f34");
        stateArray = Arrays.copyOfRange(stateArray, stateArray.length - SHA2_BLOCK_SIZE, stateArray.length);
        for (int i = 0; i < initialState.length; i++) {
          initialState[i].mapValue(BigInteger.valueOf((stateArray[i] & 0xff)), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }

        byte[] strArray = fromHexString("0000000000000002170303018d3138360d0a7b0a2020202022476c6f62616c2051756f7465223a207b0a20202020202020202230312e2073796d626f6c223a2022474f4f474c222c0a20202020202020202230322e206f70656e223a2022313130312e30343030222c0a20202020202020202230332e2068696768223a2022313130382e35393030222c0a20202020202020202230342e206c6f77223a2022313039352e39393030222c0a20202020202020202230352e207072696365223a2022313039392e31383030222c0a20202020202020202230362e20766f6c756d65223a2022353131313439222c0a20202020202020202230372e206c61746573742074726164696e6720646179223a2022323031392d30372d3031222c0a20202020202020202230382e2070726576696f757320636c6f7365223a202231303832");
        int len = strArray.length;
        for (int i = 0; i < strArray.length; i++) {
          plaintext[i].mapValue(BigInteger.valueOf((strArray[i] & 0xff)), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        for (int i = strArray.length; i < MAX_INPUT_SIZE; i++) {
          plaintext[i].mapValue(BigInteger.valueOf(0), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        length.mapValue(BigInteger.valueOf(len), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());

        byte[] stockNameArray = "GOOGL".getBytes();
        for (int i = 0; i < stockNameArray.length; i++) {
          stock_name[i].mapValue(BigInteger.valueOf((stockNameArray[i] & 0xff)), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }

        byte[] dateArray = "2019-07-01".getBytes();
        for (int i = 0; i < dateArray.length; i++) {
          date[i].mapValue(BigInteger.valueOf((dateArray[i] & 0xff)), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }

        // Price to compare with. 
        input_price_dec.mapValue(BigInteger.valueOf(1098), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        input_price_frac.mapValue(BigInteger.valueOf(1800), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());

        marker_1.mapValue(BigInteger.valueOf(50), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        marker_2.mapValue(BigInteger.valueOf(179), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        marker_3.mapValue(BigInteger.valueOf(245), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        System.out.println("Input length: " + len);
      }
      public void post() {
        System.out.println(compare.getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()));

        BigInteger stateV = new BigInteger("8fffe0a84f5eeea96d94c835b6458978b3efcba088016c441a82b20542e26c58", 16);
        byte[] stateArray = stateV.toByteArray();
        stateArray = Arrays.copyOfRange(stateArray, stateArray.length - 32, stateArray.length);
        boolean check = true;
        for (int i = 0; i < 32; i++) {
          if (!(finalState[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(BigInteger.valueOf((stateArray[i] & 0xff))))) {
            check = false;
          }
        }
        if (check) {
          System.out.println("Final State is correct!");
        } else {
          System.out.println("Failure");
          System.out.println("Circuit Output: ");
          for (int i = 0; i < finalState.length; i++) {
            System.out.print(finalState[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).toString(16) + " ,");
          }
          System.out.println();
        }
      }

    });

  }



  public void __init() {
    plaintext = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{MAX_INPUT_SIZE}, 8);
    length = new UnsignedInteger(15, new BigInteger("0"));
    marker_1 = new UnsignedInteger(32, new BigInteger("0"));
    stock_name = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{STOCK_NAME_SIZE}, 8);
    marker_2 = new UnsignedInteger(32, new BigInteger("0"));
    input_price_dec = new UnsignedInteger(20, new BigInteger("0"));
    input_price_frac = new UnsignedInteger(20, new BigInteger("0"));
    compare = Bit.instantiateFrom(false);
    marker_3 = new UnsignedInteger(32, new BigInteger("0"));
    date = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{DATE_SIZE}, 8);
    initialState = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{SHA2_BLOCK_SIZE}, 8);
    finalState = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{SHA2_BLOCK_SIZE}, 8);
  }

  public UnsignedInteger[] plaintext;
  public UnsignedInteger length;
  private SmartMemory<UnsignedInteger> plaintext_mem;
  public UnsignedInteger marker_1;
  public UnsignedInteger[] stock_name;
  public UnsignedInteger marker_2;
  public UnsignedInteger input_price_dec;
  public UnsignedInteger input_price_frac;
  public Bit compare;
  public UnsignedInteger marker_3;
  public UnsignedInteger[] date;
  public UnsignedInteger[] initialState;
  public UnsignedInteger[] finalState;

  public static int MAX_INPUT_SIZE = 500;
  public static int[] STOCK_NAME_KEY = {0x22, 0x30, 0x31, 0x2e, 0x20, 0x73, 0x79, 0x6d, 0x62, 0x6f, 0x6c, 0x22, 0x3a, 0x20};
  public static int STOCK_NAME_SIZE = 5;
  public static int[] STOCK_PRICE_KEY = {0x22, 0x30, 0x35, 0x2e, 0x20, 0x70, 0x72, 0x69, 0x63, 0x65, 0x22, 0x3a, 0x20};
  public static int MAX_STOCK_PRICE_SIZE = 6;
  public static int[] DATE_KEY = {0x22, 0x30, 0x37, 0x2e, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x74, 0x20, 0x74, 0x72, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x64, 0x61, 0x79, 0x22, 0x3a, 0x20};
  public static int DATE_SIZE = 10;
  private static int SHA2_BLOCK_SIZE = 32;
  public static int QUOTE = 0x22;
  public static int DOT = 0x2e;
  public static int ZERO = 0x30;
  @Override
  public void __defineInputs() {
    super.__defineInputs();
    input_price_dec = UnsignedInteger.createInput(this, 20);
    input_price_frac = UnsignedInteger.createInput(this, 20);


    stock_name = (UnsignedInteger[]) UnsignedInteger.createInputArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(stock_name), 8);
    date = (UnsignedInteger[]) UnsignedInteger.createInputArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(date), 8);
    initialState = (UnsignedInteger[]) UnsignedInteger.createInputArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(initialState), 8);









  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();
    UnsignedInteger.makeOutput(this, finalState);

    Bit.makeOutput(this, compare);






  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();

    length = UnsignedInteger.createVerifiedWitness(this, 15);
    marker_1 = UnsignedInteger.createVerifiedWitness(this, 32);
    marker_2 = UnsignedInteger.createVerifiedWitness(this, 32);
    marker_3 = UnsignedInteger.createVerifiedWitness(this, 32);



    plaintext = (UnsignedInteger[]) UnsignedInteger.createVerifiedWitnessArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(plaintext), 8);











  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();












  }
  public void outsource() {
    finalState = xjsnark.strings.Util.to_uint8(xjsnark.strings.Util.sha2(xjsnark.strings.Util.to_uint32(plaintext), length.copy(15), xjsnark.strings.Util.to_uint32(initialState)));

    plaintext_mem = new SmartMemory(plaintext, UnsignedInteger.__getClassRef(), new Object[]{"8"});

    // Marker #1 
    // parse key 
    UnsignedInteger cur = marker_1.copy(32);
    expect(UnsignedInteger.instantiateFrom(8, STOCK_NAME_KEY), cur.copy(32), STOCK_NAME_KEY.length);
    cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, STOCK_NAME_KEY.length)), 32);

    // parse value and check if stock name is correct.. 
    expect(plaintext_mem.read(cur).copy(8), UnsignedInteger.instantiateFrom(8, QUOTE).copy(8));
    cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, 1)), 32);
    expect(stock_name, cur.copy(32), STOCK_NAME_SIZE);
    cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, STOCK_NAME_SIZE)), 32);
    expect(plaintext_mem.read(cur).copy(8), UnsignedInteger.instantiateFrom(8, QUOTE).copy(8));
    cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, 1)), 32);

    // Marker #2 
    cur.assign(marker_2, 32);
    expect(UnsignedInteger.instantiateFrom(8, STOCK_PRICE_KEY), cur.copy(32), STOCK_PRICE_KEY.length);
    cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, STOCK_PRICE_KEY.length)), 32);

    // parse stock price 
    expect(plaintext_mem.read(cur).copy(8), UnsignedInteger.instantiateFrom(8, QUOTE).copy(8));
    cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, 1)), 32);

    UnsignedInteger current_price_dec = new UnsignedInteger(20, new BigInteger("0"));
    {
      int loop_counter_cb0xb = 0;
      while (loop_counter_cb0xb < MAX_STOCK_PRICE_SIZE) {
        {
          Bit bit_a0b0cb0xb = plaintext_mem.read(cur).isNotEqualTo(UnsignedInteger.instantiateFrom(8, DOT)).copy();
          boolean c_a0b0cb0xb = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0b0cb0xb);
          if (c_a0b0cb0xb) {
            if (bit_a0b0cb0xb.getConstantValue()) {
              current_price_dec.assign(current_price_dec.mul(UnsignedInteger.instantiateFrom(20, 10)).add(plaintext_mem.read(cur)).subtract(UnsignedInteger.instantiateFrom(20, ZERO)), 20);
              cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, 1)), 32);
            } else {

            }
          } else {
            ConditionalScopeTracker.pushMain();
            ConditionalScopeTracker.push(bit_a0b0cb0xb);
            current_price_dec.assign(current_price_dec.mul(UnsignedInteger.instantiateFrom(20, 10)).add(plaintext_mem.read(cur)).subtract(UnsignedInteger.instantiateFrom(20, ZERO)), 20);
            cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, 1)), 32);

            ConditionalScopeTracker.pop();

            ConditionalScopeTracker.push(new Bit(true));

            ConditionalScopeTracker.pop();
            ConditionalScopeTracker.popMain();
          }

        }
        loop_counter_cb0xb = loop_counter_cb0xb + 1;
      }

    }
    // dot 
    expect(plaintext_mem.read(cur).copy(8), UnsignedInteger.instantiateFrom(8, DOT).copy(8));
    cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, 1)), 32);

    UnsignedInteger current_price_frac = new UnsignedInteger(20, new BigInteger("0"));
    {
      int loop_counter_ib0xb = 0;
      while (loop_counter_ib0xb < MAX_STOCK_PRICE_SIZE) {
        {
          Bit bit_a0b0ib0xb = plaintext_mem.read(cur).isNotEqualTo(UnsignedInteger.instantiateFrom(8, QUOTE)).copy();
          boolean c_a0b0ib0xb = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0b0ib0xb);
          if (c_a0b0ib0xb) {
            if (bit_a0b0ib0xb.getConstantValue()) {
              current_price_frac.assign(current_price_frac.mul(UnsignedInteger.instantiateFrom(20, 10)).add(plaintext_mem.read(cur)).subtract(UnsignedInteger.instantiateFrom(20, ZERO)), 20);
              cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, 1)), 32);
            } else {

            }
          } else {
            ConditionalScopeTracker.pushMain();
            ConditionalScopeTracker.push(bit_a0b0ib0xb);
            current_price_frac.assign(current_price_frac.mul(UnsignedInteger.instantiateFrom(20, 10)).add(plaintext_mem.read(cur)).subtract(UnsignedInteger.instantiateFrom(20, ZERO)), 20);
            cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, 1)), 32);

            ConditionalScopeTracker.pop();

            ConditionalScopeTracker.push(new Bit(true));

            ConditionalScopeTracker.pop();
            ConditionalScopeTracker.popMain();
          }

        }
        loop_counter_ib0xb = loop_counter_ib0xb + 1;
      }

    }

    // bool compare = current_price >= input_price 
    compare.assign(Bit.instantiateFrom(false));
    {
      Bit bit_mb0xb = current_price_dec.isGreaterThan(input_price_dec).copy();
      boolean c_mb0xb = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_mb0xb);
      if (c_mb0xb) {
        if (bit_mb0xb.getConstantValue()) {
          compare.assign(Bit.instantiateFrom(true));
        } else {
          {
            Bit bit_a0a0a0a2a83a94 = (current_price_dec.isEqualTo(input_price_dec)).and((current_price_frac.isGreaterThanOrEquals(input_price_frac))).copy();
            boolean c_a0a0a0a2a83a94 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0a0a2a83a94);
            if (c_a0a0a0a2a83a94) {
              if (bit_a0a0a0a2a83a94.getConstantValue()) {
                compare.assign(Bit.instantiateFrom(true));
              } else {

              }
            } else {
              ConditionalScopeTracker.pushMain();
              ConditionalScopeTracker.push(bit_a0a0a0a2a83a94);
              compare.assign(Bit.instantiateFrom(true));

              ConditionalScopeTracker.pop();

              ConditionalScopeTracker.push(new Bit(true));

              ConditionalScopeTracker.pop();
              ConditionalScopeTracker.popMain();
            }

          }

        }
      } else {
        ConditionalScopeTracker.pushMain();
        ConditionalScopeTracker.push(bit_mb0xb);
        compare.assign(Bit.instantiateFrom(true));

        ConditionalScopeTracker.pop();

        ConditionalScopeTracker.push(new Bit(true));

        {
          Bit bit_a0a83a94_0 = (current_price_dec.isEqualTo(input_price_dec)).and((current_price_frac.isGreaterThanOrEquals(input_price_frac))).copy();
          boolean c_a0a83a94_0 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a83a94_0);
          if (c_a0a83a94_0) {
            if (bit_a0a83a94_0.getConstantValue()) {
              compare.assign(Bit.instantiateFrom(true));
            } else {

            }
          } else {
            ConditionalScopeTracker.pushMain();
            ConditionalScopeTracker.push(bit_a0a83a94_0);
            compare.assign(Bit.instantiateFrom(true));

            ConditionalScopeTracker.pop();

            ConditionalScopeTracker.push(new Bit(true));

            ConditionalScopeTracker.pop();
            ConditionalScopeTracker.popMain();
          }

        }
        ConditionalScopeTracker.pop();
        ConditionalScopeTracker.popMain();
      }

    }

    // Marker #3 
    // parse key 
    cur.assign(marker_3, 32);
    expect(UnsignedInteger.instantiateFrom(8, DATE_KEY), cur.copy(32), DATE_KEY.length);
    cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, DATE_KEY.length)), 32);

    // parse value and check if date is correct.. 
    expect(plaintext_mem.read(cur).copy(8), UnsignedInteger.instantiateFrom(8, QUOTE).copy(8));
    cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, 1)), 32);
    expect(date, cur.copy(32), DATE_SIZE);
    cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, DATE_SIZE)), 32);
    expect(plaintext_mem.read(cur).copy(8), UnsignedInteger.instantiateFrom(8, QUOTE).copy(8));
    cur.assign(cur.add(UnsignedInteger.instantiateFrom(8, 1)), 32);
  }
  public void expect(UnsignedInteger a, UnsignedInteger b) {
    a.forceEqual(b);
  }
  public void expect(UnsignedInteger[] substr, UnsignedInteger start, int len) {
    for (int j = 0; j < len; j++) {
      plaintext_mem.read(start.add(UnsignedInteger.instantiateFrom(32, j))).forceEqual(substr[j]);
    }
  }
  public static byte[] fromHexString(String src) {
    byte[] bytes = new BigInteger("10" + src.replaceAll("\\s", ""), 16).toByteArray();
    return Arrays.copyOfRange(bytes, 1, bytes.length);
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
